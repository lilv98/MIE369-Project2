//////////////////////////////////////////////////////////////////////
//
// First-Order Logic Package
//
// Class:  OtterKb (dumps kb to an otter input file for theorem proving)
// Author: Scott Sanner (ssanner@cs.toronto.edu)
// Date:   7/25/03
//
// NOTES:
// ------
// Requires OTTER_PATH to be set to the path to a compiled otter binary.
//
// TODO:
// -----
// - Should write a simple routine to parse output for query bindings.
//
//////////////////////////////////////////////////////////////////////

package logic.kb.fol;

import java.io.*;
import java.util.*;

import graph.*;
import logic.kb.*;
import logic.kb.fol.parser.*;

public class OtterKb
    implements Kb {

    public static final String OTTER_PATH = "./";

    public String _sKbName;
    public int    _nQuery;
    public Set    _sClauses;

    private OtterKb() { }

    public OtterKb(String kbname) {
	_sKbName  = kbname;
	_nQuery   = 1;
	_sClauses = new HashSet();
    }

    // TODO: Would be nice if could access streams directly and avoid file I/O
    public boolean queryFOPC(String s) {
	return queryFOPC(FOPC.parse(s));
    }

    public boolean queryFOPC(FOPC.Node n) {
	return queryFOPC(n, true);
    }

    // A bit of a hack, assumes that kb is empty, need to update this code
    // to handle refutation separately from querying, ugly for now.
    public boolean canRefute(FOPC.Node n) {
	return queryFOPC(n, false);
    }

    // A bit of a hack, assumes that kb is empty, need to update this code
    // to handle refutation separately from querying, ugly for now.
    // if prove_query_true is true, checks if query implied (negates and refutes)
    // if prove_query_true is false, checks if refutable
    public boolean queryFOPC(FOPC.Node n, boolean prove_query_true) {
	
	// Generate CNF for negation of query
	n = n.copy();
	genOtterFileForQuery(n, "query", prove_query_true);

	// Run Otter process
	try {
	    
	    Runtime rt = Runtime.getRuntime();
	    String[] params = new String[1];
	    params[0] = OTTER_PATH + "query";
	    Process p = rt.exec(params);
	    p.waitFor();

	    // Now, scan the error stream for proof
	    InputStream is = new FileInputStream("query.out");
	    int nbytes = is.available();
	    byte[] is_bytes = new byte[nbytes];
	    is.read(is_bytes);
	    String is_str = new String(is_bytes);
	    //System.out.println("Results: '" + is_str + "'");
	    if (is_str.indexOf("end of proof") >= 0) {
		return true;
	    } else {
		return false;
	    }

	} catch (IOException ioe) {
	    System.out.println("Error: " + ioe);
	    System.exit(1);
	} catch (InterruptedException e) {
	    System.out.println(e);
	    System.exit(1);
	}

	return false;
    }

    // Query for bindings of free vars
    public BindingSet queryFOPCBindings(String query) {
	System.out.println("WARNING: Bindings query not implemented for OtterKb yet.");
	return null;
    }

    public BindingSet queryFOPCBindings(FOPC.Node n) {
	System.out.println("WARNING: Bindings query not implemented for OtterKb yet.");
	return null;
    }

    // Generate an otter file for proving this query
    public void genOtterFileForQuery(String s) {
	genOtterFileForQuery(s, _sKbName + "_q" + _nQuery);
    }

    // Generate an otter file for proving this query
    public void genOtterFileForQuery(String s, String filename) {
	genOtterFileForQuery(FOPC.parse(s), filename, true);
    }

    public void genOtterFileForQuery(FOPC.Node n, String filename, 
				     boolean prove_query_true) {
	// Generate CNF for negation of query
	Set query_cnf = new HashSet();
	query_cnf.addAll(getClauses(n.convertNNF(prove_query_true)));

	// Dump file
	try {
	    PrintStream os = new PrintStream(new FileOutputStream(filename + ".in"));
	    os.println("% KB " + _sKbName + ", Query #" + _nQuery + 
		       ": FOL Kb generated from logic.kb.fol.OtterKb");
	    _nQuery++; // Increment query for next time
	    os.println();
	    os.println("set(auto).\n");
	    os.println("list(usable).");
	    
	    // Print all kb clauses
	    Iterator i = _sClauses.iterator();
	    while (i.hasNext()) {
		FOPC.Node c = (FOPC.Node)i.next();
		os.println(c.toOtterString() + ".");
	    }

	    // Print query clause
	    i = query_cnf.iterator();
	    while (i.hasNext()) {
		FOPC.Node c = (FOPC.Node)i.next();
		os.println(c.toOtterString() + ".");
	    }

	    os.println("end_of_list.");
	    os.close();

	} catch (IOException ioe) {
	    System.out.println("Error: " + ioe);
	    System.exit(1);
	}
    }

    // Convert a first-order formula to clauses and add to kb
    public void addFOPCFormula(String s) {
	_sClauses.addAll(getClauses(FOPC.parse(s)));
    }

    public void addFOPCFormula(FOPC.Node n) {
	_sClauses.addAll(getClauses(n));
    }

    public Set getClauses(FOPC.Node n) {

	// DNF conversion to push down quantifiers is pointless here
	// since we'll get rid of EXISTS and CNF(DNF) will yield
	// an exponential blowup with simplification.
	boolean SAVED_ALLOW_DNF = FOPC.ALLOW_DNF;
	FOPC.ALLOW_DNF = false;
	HashSet ret = new HashSet();

	// Simpify n and convert to NNF
	n = n.copy(); // Following functions may modify original!
	n = FOPC.simplify(n); 
	n = FOPC.skolemize(n);
	n = FOPC.convertCNF(n);

	// Break apart top-level, standardize apart free vars, and add to clause list
	if ((n instanceof FOPC.ConnNode) && 
	    ((FOPC.ConnNode)n)._nType == FOPC.ConnNode.AND) {

	    // Go through all subclauses
	    Iterator i = ((FOPC.ConnNode)n)._alSubNodes.iterator();
	    while (i.hasNext()) {
		FOPC.Node sn = (FOPC.Node)i.next();

		// Reality check!
		if (! (((sn instanceof FOPC.ConnNode) && 
			((FOPC.ConnNode)sn)._nType == FOPC.ConnNode.OR)
		       || (sn instanceof FOPC.PNode))) {

		    System.out.println("CNF conversion was bad!");
		    System.exit(1);
		}
	
		if (sn instanceof FOPC.PNode) {
		    FOPC.ConnNode cn = new FOPC.ConnNode(FOPC.ConnNode.OR);
		    cn.addSubNode(sn);
		    ret.add(cn);
		} else {
		    ret.add(sn);
		}
	    }

	} else {
	    if (! (((n instanceof FOPC.ConnNode) && 
		    ((FOPC.ConnNode)n)._nType == FOPC.ConnNode.OR)
		   || (n instanceof FOPC.PNode))) {
		
		System.out.println("CNF conversion was bad!");
		System.exit(1);
	    }
	    
	    if (n instanceof FOPC.PNode) {
		FOPC.ConnNode cn = new FOPC.ConnNode(FOPC.ConnNode.OR);
		cn.addSubNode(n);
		ret.add(cn);
	    } else {
		ret.add(n); 
	    } 
	}

	// Restore DNF conversion
	FOPC.ALLOW_DNF = SAVED_ALLOW_DNF;
	return ret;
    }
}
