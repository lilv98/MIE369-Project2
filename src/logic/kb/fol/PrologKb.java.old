//////////////////////////////////////////////////////////////////////
//
// First-Order Logic Package
//
// Class:  PrologKb (recursively evaluates predicates under closed-world
//                   assumption and possibly a domain closure assumption)
// Author: Scott Sanner (ssanner@cs.toronto.edu)
// Date:   1/20/05
//
// NOTES:
// ------
//  - TOP_DOMAIN matches any object under a domain closure assumption.
//    Undefined otherwise.
//  - Enforces a very strict stratification, predicates cannot be
//    both rule and ground defined.  Rule predicates *should not*
//    reference themselves in the body (although this is legal syntax).
//  - Rule heads with redundant vars not allowed, but queries with
//    redundant vars are allowed.
//
// TODO:
// -----
//  - Handle FORALL quantified => (efficient constraint check)
//  - Allow specification of TRANSITIVE predicates (and separate eval rule)
//  - Handle EQUALITY/INEQUALITY
//  - Handle NUMERICAL COMPARISONS
//  - Might want to take a more Prolog-like approach.  Evaluate
//    body on it's own, then map back into parent PNode... would
//    allow repeated variables in head as well as generic matching
//    of for heads with functions (just map entire ground function,
//    into calling PNode).
//  - Also Prolog would require passing current bindings during
//    conjunction to avoid infinite recursion.  (All in all, it seems
//    to me that it would be difficult to integrate this version
//    of a logic matcher including quantifiers with the simple view
//    of conjunctive Prolog rules... should define another Kb for
//    actual Prolog if wanted.)
//  - Prolog efficiency optimizations, when to cut off early, add
//    explicit cut operator.
//  - Rule predicates cannot have repeated variables.
//  - BindingSet currently uses a String interface... this can be
//    extremely inefficient.
//  - Could automatically insert TOP_DOMAIN and Existentials based on
//    var subset relationship between rule head and rule body.
//
//////////////////////////////////////////////////////////////////////

package logic.kb.fol;

import java.io.*;
import java.util.*;

import graph.*;
import logic.kb.*;

/** PrologKb class
 *
 *  - Assert which predicates are ground (CWA will assume non-asserted
 *    atoms are false).
 *  - Assert which predicates are defined (can have multiple definitions).
 *  - If domain closure, need to specify all objects.  Can use unary
 *    class predicates to enforce typing of variables.
 *  - Can assert ground predicates (CWA implies all non-asserted ground
 *    predicates are false, or true if a predicate is marked as such.)
 *  - All queries operate via binding sets.
 **/
public class PrologKb
    extends Kb {

    // Set to -1 to disable
    public final static int DISPLAY_TO_DEPTH = -1;
    public final static boolean USE_CACHE = true;

    public boolean _bDomainClosed;
    public HashMap _hmGroundPred;  // Maps Pred -> BindingSet
    public HashMap _hmDefinedPred; // Maps Pred -> HashSet of Rules
    public HashSet _hsDomainObjects;
    public HashMap _hmBindingsCache;
    public int     _nCurDepth;

    // CWA assumed, domain closure optional (specify as false if domain is null)
    public PrologKb(Collection domain) { 
	_nCurDepth     = 0;
	_hmGroundPred  = new HashMap();
	_hmDefinedPred = new HashMap();
	if (USE_CACHE) {
	    _hmBindingsCache = new HashMap();
	}
	if (domain == null) {
	    _bDomainClosed = false;
	} else {
	    _bDomainClosed   = true;
	    _hsDomainObjects = new HashSet(domain);
	    Iterator i = domain.iterator();
	    while (i.hasNext()) {
		FOPC.PNode p = new FOPC.PNode(false, "TOP_DOMAIN");
		p.addBinding((FOPC.Term)i.next());
		addGroundBinding(p);
	    }
	}
    }

    public float getQueryTime() {
	System.out.println("TODO: PrologKb.getQueryTime");
	return -1f;
    }

    public int getNumInfClauses() {
	System.out.println("TODO: PrologKb.getNumInfClauses");
	return -1;
    }

    public int getProofLength() {
	System.out.println("TODO: PrologKb.getProofLen");
	return -1;	
    }

    // See below

    // TODO: Would be nice if could access streams directly and avoid file I/O
    public boolean queryFOPC(String s) {
	return queryFOPC(FOPC.parse(s));
    }

    // Must have free variables... returns true if support found.
    // If no free variables, converts P(1,2,3) -> P(1,2,?c) ^ P(1,2,3)
    public boolean queryFOPC(FOPC.Node n) {

	Bindings b = eval(n);
	return (b.getNumEntries() > 0);
    }

    public boolean queryFOPC(String assume, String query) {
	return queryFOPC(FOPC.parse(assume), FOPC.parse(query));
    }

    public boolean queryFOPC(FOPC.Node assume, FOPC.Node query) {
	System.out.println("TODO: PrologKb.queryFOPC with assumptions.");
	System.exit(1);
	return false;	
    }

    // See below
    public BindingSet queryFOPCBindings(String query) {
	return queryFOPCBindings(FOPC.parse(query));
    }
    
    // Query for bindings of free vars
    public BindingSet queryFOPCBindings(FOPC.Node n) {
	Bindings b = eval(n);
	//System.out.println(n.toFOLString() + ": " + b); // Remove
	return b.convert2BindingSet(); 
    }

    public BindingSet queryFOPCBindings(String assume, String query) {
	return queryFOPCBindings(FOPC.parse(assume), FOPC.parse(query));
    }

    public BindingSet queryFOPCBindings(FOPC.Node assume, FOPC.Node query) {
	System.out.println("TODO: PrologKb.queryFOPCBindings with assumptions.");
	System.exit(1);
	return null;	
    }

    // See below
    public void addFOPCFormula(String s) {
	addFOPCFormula(FOPC.parse(s));
    }

    // Must be a ground atom or a FOPC.ConnNode, handled accordingly
    public void addFOPCFormula(FOPC.Node n) {

	if (n instanceof FOPC.PNode) {

	    addGroundBinding((FOPC.PNode)n);

	} else if (n instanceof FOPC.ConnNode) {

	    FOPC.ConnNode c = (FOPC.ConnNode)n;
	    c.substitute(FOPC.standardizeApartNode(c));
	    if (c._nType != FOPC.ConnNode.IMPLY || c._alSubNodes.size() != 2) {
		System.out.println("Need a => rule with 1 lhs and 1 rhs... missing parentheses?");
		System.out.println("Node: " + c.toFOLString());
		System.exit(1);
	    }
	    FOPC.PNode head = (FOPC.PNode)c._alSubNodes.get(1);
	    FOPC.Node  body = (FOPC.Node)c._alSubNodes.get(0);

	    // Check for repeated vars in terms
	    HashSet vars = new HashSet();
	    Iterator i = head._alTermBinding.iterator();
	    while (i.hasNext()) {
	    	FOPC.Term t = (FOPC.Term)i.next();
	    	Set new_vars = t.collectVars();
	    	Iterator j = new_vars.iterator();
	    	while (j.hasNext()) {
	    	    FOPC.TVar v = (FOPC.TVar)j.next();
	    	    if (vars.contains(v)) {
	    		System.out.println("Rule head contains redundant variable: " + v.toFOLString());
	    		System.out.println("Head: " + head.toFOLString() + ", Body: " + body.toFOLString());
	    		System.exit(1);
	    	    }
	    	}
	    	vars.addAll(new_vars);
	    }

	    addRule(head, body);

	} else {
	    System.out.println("PrologKb: Can only assert implications");
	    System.exit(1);
	}
    }

    /////////////////////////////////////////////////////////////////////////////////////////

    // The main eval function
    public Bindings eval(FOPC.Node n) {

	if (_nCurDepth < DISPLAY_TO_DEPTH) {
	    System.out.println("EVAL: " + n.toFOLString());
	}
	Bindings ret = null;
	if (!USE_CACHE || ((ret = (Bindings)_hmBindingsCache.get(n.toFOLString())) == null)) {

	    _nCurDepth++;
	    //n = n.pushDownQuant();
	    n.setFreeVars();
	    if (n instanceof FOPC.QNode) {
		
		ret = evalQuant((FOPC.QNode)n);

	    } else if (n instanceof FOPC.ConnNode) {
		
		ret = evalConn((FOPC.ConnNode)n);
		
	    } else if (n instanceof FOPC.PNode) {
		
		FOPC.PNode p = (FOPC.PNode)n;
		if (p._nPredID == FOPC.PNode.EQUALS) {
		    //System.out.println("EVAL EQUALITY");
		    ret = evalEquality(p);
		} else {
		    Pred pred = new Pred(p._sPredName, p._nArity);
		    if (_hmDefinedPred.get(pred) != null) {
			ret = evalRules(p);
		    } 
		    if (_hmGroundPred.get(pred) != null) {
			Bindings b = evalGround(p);
			if (ret == null) {
			    ret = b;
			} else {
			    ret = Union(b, ret);
			}
		    } 
		    if (ret == null) {
			
			// PNode must have no instantations
			ret = new Bindings(new ArrayList(p._hsFreeVarsOut));
		    }
		}
		
	    } else if (n instanceof FOPC.NNode) {
		
		ret = Negate(eval(((FOPC.NNode)n)._subnode));
		
	    } else { // Error: unhandled node
		
		System.out.println("Error: " + n.toFOLString() + 
				   " not handled by current interpreter");
		System.exit(1);
	    }
	    
	    if (ret != null) {
		if (USE_CACHE) {
		    _hmBindingsCache.put(n.toFOLString(), ret);
		}
		//System.out.println("- Return size: " + ret._bindings.size());
	    }
	    
	    _nCurDepth--;
	}

	if (_nCurDepth < DISPLAY_TO_DEPTH) {
	    System.out.println("RESULT: " + ret);
	}
	//if (_nCurDepth == 0 && ret._bindings.size() > 0) {
	//    System.exit(1);
	//}
	return ret;
    }

    public Bindings evalQuant(FOPC.QNode q) {

	// Start on inside and work out
	LinkedList quant_type = new LinkedList(q._alQuantType);
	LinkedList quant_bind = new LinkedList(q._alQuantBinding);
	Bindings rval = eval(q._subnode);
	//System.out.println("- Results of eval: " + q._subnode.toFOLString());
	//System.out.println(rval);

	while (!quant_type.isEmpty()) {
	    int quant   = ((Integer)quant_type.removeLast()).intValue();
	    FOPC.TVar v = (FOPC.TVar)quant_bind.removeLast();
	    if (rval._vars.indexOf(v) >= 0) {
		
		if (quant == q.EXISTS) {
		    
		    // Project out v
		    rval = Project(rval, v);
		    
		} else if (quant == q.FORALL) {
		    
		    // Universally quantify out v
		    rval = UnivQuant(rval, v);
		    
		} else {
		    System.out.println("Invalid quantifier ID: " + quant);
		    System.exit(1);
		}

	    } else {
		// Skip var because extraneous
	    }
	}
	
	return rval;
    }

    public Bindings evalConn(FOPC.ConnNode c) {

	if (c._nType == FOPC.ConnNode.AND) {

	    // Handle conjunction
	    Bindings ret = null;
	    Iterator i = c._alSubNodes.iterator();
	    //System.out.println("CONJ: " + c.toFOLString());
	    while (i.hasNext()) {
		FOPC.Node n = (FOPC.Node)i.next();
		Bindings rval = eval(n);
		//System.out.println("Interm: " + n.toFOLString() + ":\n" + rval);
		if (ret == null) {
		    ret = rval;
		} else {
		    //System.out.println("Joining:");
		    //System.out.println(rval);
		    //System.out.println(ret);
		    ret = Join(ret, rval);
		    //System.out.println("Result\n" + ret);
		}

		if (ret._bindings.size() == 0) {
		    // Could possibly add remaining free vars
		    break; // Will not join with anything else.
		} else if (ret._bindings.size() > 1000) {
		    System.out.println(" [Joined AND [" + ret._bindings.size() + "]: " + c.toFOLString() + "] \n\n" + ret);
		}
	    }
	    //System.out.println("Final:\n" + ret);
	    return ret;

	} else if (c._nType == FOPC.ConnNode.OR) {

	    if (_bDomainClosed) {

		// Handle disjunction under CWA and DC (i.e., take
		// a_1 v ... v a_n = ~(~a_1 ^ ... ^ ~a_n)
		Bindings ret = null;
		Iterator i = c._alSubNodes.iterator();
		while (i.hasNext()) {
		    FOPC.Node n = (FOPC.Node)i.next();
		    Bindings rval = Negate(eval(n));
		    //System.out.println("CONJ Result: " + n.toFOLString() + ":");
		    //System.out.println(rval);
		    if (ret == null) {
			ret = rval;
		    } else {
			//System.out.println("Joining:");
			//System.out.println(rval);
			//System.out.println(ret);
			ret = Join(ret, rval);
			//System.out.println("Result\n" + ret);
		    }
		    if (ret._bindings.size() == 0) {
			break; // Will not join with anything else.
		    } else if (ret._bindings.size() > 50000) {
			System.out.println(" [Joined OR/DC [" + ret._bindings.size() + "]: " + c.toFOLString() + "] ");
		    }
		}
		return Negate(ret);		

	    } else {

		// Handle disjunction under CWA only (i.e., union)
		Bindings ret = null;
		Iterator i = c._alSubNodes.iterator();
		while (i.hasNext()) {
		    FOPC.Node n = (FOPC.Node)i.next();
		    Bindings rval = eval(n);
		    //System.out.println("CONJ Result: " + n.toFOLString() + ":");
		    //System.out.println(rval);
		    if (ret == null) {
			ret = rval;
		    } else {
			HashSet h1 = new HashSet(ret._vars);
			HashSet h2 = new HashSet(rval._vars);
			if (!h1.equals(h2)) {
			    System.out.println("Trying to disjoin: " + c.toFOLString());
			    System.out.println("But nodes have differing numbers of variables");
			    System.exit(1);
			}
			//System.out.println("Unioning:");
			//System.out.println(rval);
			//System.out.println(ret);
			ret = Union(ret, rval);
			//System.out.println("Result\n" + ret);
		    }
		    if (ret._bindings.size() > 50000) {
			System.out.println(" [Joined OR/CWA [" + ret._bindings.size() + "]: " + c.toFOLString() + "] ");
		    }
		}
		return ret;
	    } 

	} else if (c._nType == FOPC.ConnNode.IMPLY) {
	    return evalConn(new FOPC.ConnNode(FOPC.ConnNode.OR,
					      new FOPC.NNode((FOPC.Node)c._alSubNodes.get(0)),
					      (FOPC.Node)c._alSubNodes.get(1)));
	} else {
	    
	    // Invalid!!!
	    System.out.println("Invalid connective ID: " + c._nType);
	    System.out.println(c.toFOLString());
	    System.exit(1);

	}

	// Should not get here
	return null;
    }

    public Bindings evalRules(FOPC.PNode p) {

	Bindings ret = new Bindings(new ArrayList(p._hsFreeVarsOut));
	p.setFreeVars();
	HashSet rules = getRuleSet(new Pred(p._sPredName, p._nArity), false);
	Iterator i = rules.iterator();
	while (i.hasNext()) {
	    Rule r = (Rule)i.next();

	    // First check if there is a direct var-to-var mapping between
	    // the head and the body, if so, substitute the correct variables
	    // in the body and return.
	    //boolean all_vars = true;
	    //ArrayList terms = p._alTermBinding;
	    //int i;
	    //for (i = 0; i < terms.size() && all_vars; i++) {
	    //	all_vars = (terms.get(i) instanceof FOPC.TVar) &&
	    //	           (r._head.get(i) instanceof FOPC.TVar);
	    //}
	    //if (all_vars && p._alTermBinding.size() == p._hsFreeVarsOut.size()
	    //	         && p._alTermBinding.size() == r._head._alTermBinding.size()) {
	    //	
	    //	// A different var for every term binding, just return copy of _bindings
	    //	// and every var different.
	    //	HashMap unifier = FOPC.unify(r._head, p); // Must succeed, all variables
	    //	FOPC.Node body = r._body.copy();
	    //	body.substitute(unifier);
	    //	body.setFreeVars();
	    //	return eval(body);
	    //} 

	    // Otherwise we need to go through entries in rval to see if we can
	    // put them in the return set.

	    // PNode p(?x,g(?x,?y),?x,f(?y))          ret:  [?x, ?y]
	    // Head  p(g(?v11),?v12?,?v12,f(?v13))    rval: [?v11, ?v12]
	    //Bindings rval = eval(r._body);
	    //Bindings ret = new Bindings(new ArrayList(p._hsFreeVarsOut));
	    //ArrayList ret_entry = new ArrayList();
	    //
	    //Iterator j = rval._bindings.iterator();
	    //while (j.hasNext()) {
	    //	ArrayList entry = (ArrayList)j.next();
	    //	ret_entry.clear();
	    //	for (i = 0; i < ret._vars.size(); i++) {
	    //	    ret_entry.add(null);
	    //	}
	    //}

	    // Get unifier for head 
	    HashMap unifier = FOPC.unify(r._head, p);

	    if (unifier != null) {

		// Check that all unifier substitutions are constants or vars from PNode
		Iterator j = unifier.values().iterator();
		boolean all_vars_in_pnode = true;
		while (j.hasNext()) { 
		    FOPC.Term t = (FOPC.Term)j.next();
		    if (t.collectVars().isEmpty()) { //
			continue;
		    }
		    if (!(t instanceof FOPC.TVar) || !p._hsFreeVarsOut.contains(t)) {
			all_vars_in_pnode = false;
			break;
		    }
		}
		if (!all_vars_in_pnode) {
		    continue;
		}

		// Substitute and evaluate
		FOPC.Node body = r._body.copy();
		body.substitute(unifier);
		body.setFreeVars();
		Bindings rval  = eval(body);

		// HashSet should always preserve same order in return set
		// so this should not be an issue.
		if (!rval._vars.equals(ret._vars)) {
		    System.out.println("evalRules(): Var mismatch!");
		    System.out.println("PNode: " + p.toFOLString());
		    System.out.println("Rule:  " + r);
		    System.out.println(rval._vars + ", " + ret._vars);
		    System.out.println("First vars from: " + body.toFOLString());
		    System.out.println(unifier);
		    System.exit(1);
		}

		// Add bindings from this rule
		ret = Union(ret, rval);
	    }
	}

	return (p._bIsNegated ? Negate(ret) : ret);
    }

    public Bindings evalEquality(FOPC.PNode p) {

	// Check for equality
	//System.out.println(p._sPredName + ", " + p._nPredID);
	if (p._nPredID == FOPC.PNode.EQUALS) {
	    int bind_sz = p._hsFreeVarsOut.size();
	    Bindings b = new Bindings(new ArrayList(p._hsFreeVarsOut));
	    if (bind_sz == 0) {
		System.out.println("Error: ground equality: " + p.toFOLString());
		System.exit(1);
	    } else if (bind_sz == 1) {
		FOPC.Term t1 = (FOPC.Term)p._alTermBinding.get(0);
		ArrayList binding = new ArrayList();
		if (t1 instanceof FOPC.TVar) {
		    binding.add(p._alTermBinding.get(1));
		    b._bindings.add(binding);		    
		} else {
		    binding.add(t1);
		    b._bindings.add(binding);
		}
	    } else if (bind_sz == 2) {
		if (_bDomainClosed) {
		    Iterator obji = _hsDomainObjects.iterator();
		    while (obji.hasNext()) {
			ArrayList a = new ArrayList();
			FOPC.Term t = (FOPC.Term)obji.next();
			a.add(t); a.add(t);
			b._bindings.add(a);
		    }
		} else {
		    System.out.println("Domain closure required for equality with 2 free vars");
		    System.exit(1);
		}
	    }
	    Bindings b2 = (p._bIsNegated ? Negate(b) : b);
	    //System.out.println("EVAL EQ (Postnegate):\n" + p.toFOLString() + ":" + b2);
	    return b2;
	} else {
	    System.out.println("Not equality!");
	    System.exit(1);
	    return null;
	}
    }

    public Bindings evalGround(FOPC.PNode p) {

	GroundBindings gb = getGroundBindings(new Pred(p._sPredName, p._nArity), false);

	// Check if p all vars
	boolean all_vars = true;
	ArrayList terms = p._alTermBinding;
	int i;
	for (i = 0; i < terms.size() && all_vars; i++) {
	    all_vars = (terms.get(i) instanceof FOPC.TVar);
	}
	if (all_vars && p._alTermBinding.size() == p._hsFreeVarsOut.size()) {
		
	    // A different var for every term binding, just return copy of _bindings
	    // and every var different.
	    Bindings b = new Bindings(p._alTermBinding);
	    b._bindings.addAll(gb._bindings._bindings);
	    return (p._bIsNegated ? Negate(b) : b);
	} 

	// Otherwise, we have to check for matches
	Bindings ret = new Bindings(new ArrayList(p._hsFreeVarsOut));

	ArrayList entry = new ArrayList();
	int gb_size = gb._bindings._vars.size();
	int[] g_to_ret = new int[gb_size];
	for (i = 0; i < gb_size; i++) {
	    FOPC.Term t = (FOPC.Term)terms.get(i);
	    if (t instanceof FOPC.TVar) {
		g_to_ret[i] = ret._vars.indexOf(t);		
	    }
	}

	// Now, go through each entry in binding set and determine if it matches
	Iterator j = gb._bindings.getIterator();
	while (j.hasNext()) {
	    ArrayList binding = (ArrayList)j.next();
	    entry.clear();
	    for (i = 0; i < ret._vars.size(); i++) {
		entry.add(null);
	    }
	    boolean match = true;
	    
	    for (int index = 0; index < binding.size(); index++) {
		FOPC.Term node_t   = (FOPC.Term)terms.get(index);
		FOPC.Term ground_t = (FOPC.Term)binding.get(index);
		if (node_t instanceof FOPC.TVar) {
		    //System.out.println(p.toFOLString() + p._hsFreeVarsOut + " comp " + binding);
		    //System.out.println("Length: " + g_to_ret.length);
		    FOPC.Term cur = (FOPC.Term)entry.get(g_to_ret[index]);
		    if (cur == null || cur.equals(ground_t)) {
			entry.set(g_to_ret[index], ground_t);
		    } else {
			// Current entry clashed with new entry
			match = false;
			break;
		    }
		} else { 

		    // Need to see if node_t unifies with ground_t
		    // --> theta would have to be vars in node_t for ground
		    HashMap unifier = FOPC.unify(node_t, ground_t);
		    if (unifier == null) {
			match = false;
			break;
		    }
		    //System.out.println("Successfully unified: " + 
		    //	       node_t.toFOLString() + 
		    //	       ", " + ground_t.toFOLString());
		    
		    Iterator u = unifier.entrySet().iterator();
		    while (u.hasNext()) {
			Map.Entry me = (Map.Entry)u.next();
			FOPC.TVar v  = (FOPC.TVar)me.getKey();
			FOPC.Term value = (FOPC.Term)me.getValue();
			//System.out.println("- Unifier: " + v.toFOLString() + " -> "
			//		   + value.toFOLString());
			int index2 = ret._vars.indexOf(v);
			FOPC.Term cur = (FOPC.Term)entry.get(index2);
			if (cur == null || cur.equals(value)) {
			    entry.set(index2, value);
			} else {
			    // Current entry clashed with new entry
			    match = false;
			    break;
			}
		    }
		}
	    }
	    if (match) {
		ret._bindings.add(entry.clone());
	    }
	}

	return (p._bIsNegated ? Negate(ret) : ret);
    }

    /////////////////////////////////////////////////////////////////////////////////////////

    public Bindings Union(Bindings b1, Bindings b2) {

	if (!(new HashSet(b1._vars)).equals(new HashSet(b2._vars))) {
	    System.out.println("Cannot union non-equivalent var sets");
	    System.out.println("B1: " + b1._vars);
	    System.out.println("B2: " + b2._vars);
	}

	// Check if vars align... then just combine directly
	if (b1._vars.equals(b2._vars)) {
	    Bindings ret = new Bindings(b1._vars);
	    ret._bindings.addAll(b1._bindings);
	    ret._bindings.addAll(b2._bindings);
	    return ret;
	}

	// Vars don't align so need to match one to the other
	if (b2._bindings.size() > b1._bindings.size()) {
	    Bindings tmp = b1;
	    b1 = b2;
	    b2 = tmp;
	}

	int sz = b1._vars.size();
	Bindings ret = new Bindings(b1._vars);
	ret._bindings.addAll(b1._bindings);

	int[] b1_to_b2 = new int[sz];
	int index;
	for (index = 0; index < sz; index++) {
	    b1_to_b2[index] = b2._vars.indexOf(b1._vars.get(index));
	}

	Iterator i = b2._bindings.iterator();
	while (i.hasNext()) {
	    ArrayList bindings = (ArrayList)i.next();
	    ArrayList entry = new ArrayList();
	    for (index = 0; index < sz; index++) {
		entry.add(bindings.get(b1_to_b2[index]));
	    }
	    ret._bindings.add(entry);
	}
	return ret;
    }

    public Bindings Join(Bindings b1, Bindings b2) {

	//System.out.println("Joining:");
	//System.out.println(b1);
	//System.out.println(b2);	

	// Make b1 the smallest set of bindings
	if (b2._bindings.size() < b1._bindings.size()) {
	    Bindings tmp = b1;
	    b1 = b2;
	    b2 = tmp;
	}

	// Generate superset of vars
	HashSet tvars = new HashSet(b1._vars);
	tvars.addAll(b2._vars);
	ArrayList new_vars = new ArrayList(tvars);
	Bindings ret = new Bindings(new_vars);
	ArrayList entry = new ArrayList();
	int i;
	for (i = 0; i < new_vars.size(); i++) {
	    entry.add(null);
	}

	// Generate map from b1 to ret, and b2 to ret
	int[] b1_to_ret = new int[b1._vars.size()];
	for (i = 0; i < b1._vars.size(); i++) {
	    FOPC.TVar v = (FOPC.TVar)b1._vars.get(i);
	    b1_to_ret[i] = new_vars.indexOf(v);
	}
	int[] b2_to_b1  = new int[b2._vars.size()];
	int[] b2_to_ret = new int[b2._vars.size()];
	for (i = 0; i < b2._vars.size(); i++) {
	    FOPC.TVar v = (FOPC.TVar)b2._vars.get(i);
	    b2_to_b1[i]  = b1._vars.indexOf(v); // -1 if not found
	    b2_to_ret[i] = new_vars.indexOf(v);
	}
	
	// Go through each element in b1 and b2...
	//   For each b1 subset that matches b2, add
	//   the entry to ret

	//System.out.println("B1: " + b1._bindings.size() + ", " + b1._vars);
	Iterator j = b1._bindings.iterator();
	while (j.hasNext()) {
	    ArrayList bind1 = (ArrayList)j.next();
	    for (i = 0; i < b1._vars.size(); i++) {
		entry.set(b1_to_ret[i], (FOPC.Term)bind1.get(i));
	    }
	    //System.out.println("B2: " + b2._bindings.size() + ", " + b2._vars);
	    Iterator k = b2._bindings.iterator();
	    while (k.hasNext()) {
		ArrayList bind2 = (ArrayList)k.next();
		boolean match = true;
		for (i = 0; i < b2._vars.size(); i++) {
		    if (b2_to_b1[i] >= 0) {
			if (!bind1.get(b2_to_b1[i]).equals(bind2.get(i))) {
			    match = false;
			    break; // Not a match, skip bind2
			} // Otherwise a match
		    } else { // Not in b1, so add it to entry
			entry.set(b2_to_ret[i], (FOPC.Term)bind2.get(i));
		    }
		}
		if (match) {
		    // If we got here, must be a match
		    ret.addEntry((ArrayList)entry.clone());
		}
	    }
	}

	return ret;
    }

    // This can be extremely inefficient because |domain|^|vars|
    // Should try to focus on => constraint method.
    public Bindings Negate(Bindings b) {
	
	if (!_bDomainClosed) {
	    System.out.println("Cannot negate without domain closure");
	    System.exit(1);
	}
	Bindings ret = GenFullBindings(b._vars);
	
	// Remove each binding in b from ret
	Iterator i = b._bindings.iterator();
	while (i.hasNext()) {
	    ArrayList bindings = (ArrayList)i.next();
	    ret._bindings.remove(bindings);
	}

	return ret;
    }

    public Bindings Project(Bindings b, FOPC.TVar to_remove) {
	
	// Get new set of vars
	int var_index = b._vars.indexOf(to_remove);
	if (var_index < 0) {
	    System.out.println("PrologKb Project ERROR: " + to_remove.toFOLString());
	    System.out.println(b);
	    // Will cause ArrayIndex Exception
	}
	ArrayList new_vars = (ArrayList)b._vars.clone();
	new_vars.remove(var_index);
	Bindings ret = new Bindings(new_vars);

	// Now copy and remove var_index in each binding
	Iterator i = b._bindings.iterator();
	while (i.hasNext()) {
	    ArrayList newb = (ArrayList)((ArrayList)i.next()).clone();
	    newb.remove(var_index);
	    ret.addEntry(newb);
	}

	return ret;
    }

    public Bindings UnivQuant(Bindings b, FOPC.TVar to_remove) {
		
	if (!_bDomainClosed) {
	    System.out.println("Cannot negate without domain closure");
	    System.exit(1);
	}

	Bindings proj = Project(b, to_remove);
	Bindings ret  = new Bindings(proj._vars);
	ArrayList b_entry = new ArrayList();
	int[] ret_to_b = new int[ret._vars.size()];
	int i;
	for (i = 0; i < ret._vars.size(); i++) {
	    ret_to_b[i] = b._vars.indexOf(ret._vars.get(i));
	}
	int var_index = b._vars.indexOf(to_remove);
	
	Iterator j = proj._bindings.iterator();
	while (j.hasNext()) {
	    ArrayList r_entry = (ArrayList)j.next();
	    b_entry = reset(b_entry, b._vars.size());

	    for (i = 0; i < ret._vars.size(); i++) {
		b_entry.set(ret_to_b[i], r_entry.get(i));
	    }

	    // Verify r_entry contains all values in domain
	    boolean match = true;
	    Iterator k = _hsDomainObjects.iterator();
	    while (k.hasNext()) {
		FOPC.Term dom_obj = (FOPC.Term)k.next();
		b_entry.set(var_index, dom_obj);
		if (!b._bindings.contains(b_entry)) {
		    match = false;
		    break;
		}
	    }
	    if (match) {
		ret._bindings.add(r_entry);
	    }
	}

	return ret;
    }

    public ArrayList reset(ArrayList a, int sz) {
	a.clear();
	for (int i = 0; i < sz; i++) {
	    a.add(null);
	}
	return a;
    }

    public Bindings GenFullBindings(ArrayList vars) {
	Bindings b = new Bindings(vars);
	HashSet bindings = new HashSet();
	GenRecurse(vars.size(), new ArrayList(), bindings);
	b._bindings = bindings;
	return b;
    }
    
    // Returns ArrayList of ArrayLists of all combinations of elements in domain
    public void GenRecurse(int vars_left, ArrayList cur, HashSet ret) {
	if (vars_left == 0) {
	    ret.add((ArrayList)cur.clone());
	} else {
	    Iterator i = _hsDomainObjects.iterator();
	    int index = cur.size();
	    while (i.hasNext()) {
		cur.add(i.next());
		GenRecurse(vars_left - 1, cur, ret);
		cur.remove(index);
	    }
	}
    }

    /////////////////////////////////////////////////////////////////////////////////////////

    // Add a ground binding
    public void addGroundBinding(FOPC.PNode p) {

	// Check negation
	if (p._bIsNegated) {
	    System.out.println("By CWA, do not need to assert false bindings.");
	    System.out.println("PNode: " + p.toFOLString());
	    return;
	}

	// Verify all bindings are constants or constant functions
	ArrayList terms = p._alTermBinding;
	Iterator i = terms.iterator();
	while (i.hasNext()) {
	    FOPC.Term t = (FOPC.Term)i.next();
	    Set vars = t.collectVars();
	    if (!vars.isEmpty()) {
		System.out.println("Cannot assert nonground PNode.");
		System.out.println("PNode: " + p.toFOLString());
		return;		
	    }
	}

	// OK, so add bindings
	Pred pred = new Pred(p._sPredName, p._nArity);
	GroundBindings gb = getGroundBindings(pred, true);
	gb._bindings.addEntry(terms);

	// Check for clash
	if (_hmDefinedPred.get(pred) != null) {
	    System.out.println("ERROR: " + p.toFOLString() + 
			       " has both ground and rule entries.");
	    System.exit(1);
	}
    }

    // Get GroundBindings (PNode _prototype, _bindings)  for ground predicate...
    // If none exists and create then make a new one, bind it and
    // return; if not create then return null.
    public GroundBindings getGroundBindings(Pred p, boolean create) {
	GroundBindings gb = (GroundBindings)_hmGroundPred.get(p);
	if (gb == null && create) {
	    // Make a prototype PNode
	    FOPC.PNode proto = new FOPC.PNode(false, p._sName);
	    ArrayList vars = new ArrayList();
	    for (int i = 0; i < p._nArity; i++) {
		FOPC.TVar v = new FOPC.TVar();
		vars.add(v);
		proto.addBinding(v);
	    }
	    Bindings b = new Bindings(vars);
	    gb = new GroundBindings(proto, b);
	    _hmGroundPred.put(p, gb);
	}
	return gb;
    }

    // Add a rule to the rule set
    public void addRule(FOPC.PNode head, FOPC.Node body) {
	Pred p = new Pred(head._sPredName, head._nArity);
	HashSet h = getRuleSet(p, true);
	h.add(new Rule(head, body));

	// Check for clash
	if (_hmGroundPred.get(p) != null) {
	    System.out.println("ERROR: " + head.toFOLString() + 
			       " has both ground and rule entries.");
	    System.exit(1);
	}
    }

    // How to handle pred with functions?
    public HashSet getRuleSet(Pred p, boolean create) {
	// Returns the set of rule bodies
	HashSet rules = (HashSet)_hmDefinedPred.get(p);
	if (rules == null && create) {
	    rules = new HashSet();
	    _hmDefinedPred.put(p, rules);
	}
	return rules;
    }

    // Helper function for set determination: true if 'a' superset of 'b'
    public static boolean SuperSet(Set a, Set b) {
	Iterator i = b.iterator();
	while (i.hasNext()) {
	    if (!a.contains(i.next())) {
		return false;
	    }
	}
	return true;
    }

    // Dump the kb
    public String toString() {
	StringBuffer sb = new StringBuffer();
	sb.append("****************  Prolog Kb  **************\n");
	sb.append("Rules:\n------\n");
	Iterator i = _hmDefinedPred.entrySet().iterator();
	while (i.hasNext()) {
	    Map.Entry me = (Map.Entry)i.next();
	    Pred p = (Pred)me.getKey();
	    HashSet rules = (HashSet)me.getValue();
	    Iterator j = rules.iterator();
	    while (j.hasNext()) {
		Rule r = (Rule)j.next();
		sb.append("- " + p + ": " + r + "\n");
	    }
	}
	i = _hmGroundPred.entrySet().iterator();
	while (i.hasNext()) {
	    Map.Entry me = (Map.Entry)i.next();
	    Pred p = (Pred)me.getKey();
	    GroundBindings gb = (GroundBindings)me.getValue();
	    sb.append("\n" + p + ": " + gb);
	}
	sb.append("*******************************************\n");
	return sb.toString();
    }

    /////////////////////////////////////////////////////////////////////////////////////////

    /** Internal class for comparing predicates
     **/
    public static class Pred {
	public String _sName;
	public int    _nArity;
	public Pred(String name, int arity) {
	    _sName  = name;
	    _nArity = arity;
	}
	public int hashCode() {
	    return _sName.hashCode() - _nArity;
	}
	public boolean equals(Object o) {
	    Pred p = (Pred)o;
	    return (_sName.equals(p._sName) &&
		    _nArity == p._nArity);
	}
	public String toString() {
	    return _sName + "_" + _nArity;
	}
    }

    /** Internal class for storing rules
     **/
    public static class Rule {
	public FOPC.PNode _head; // Head and body must share
	public FOPC.Node  _body; // same free variables
	public Rule(FOPC.PNode head, FOPC.Node body) {
	    _head = head;
	    _body = body; //.convertNNF(false);
	    _head.setFreeVars();
	    _body.setFreeVars();
	    if (!_head._hsFreeVarsOut.equals(_body._hsFreeVarsOut)) {
		System.out.println("Head and body must have same free var set");
		System.out.println("Head: " + _head.toFOLString() + ": " + 
				   _head._hsFreeVarsOut);
		System.out.println("Body: " + _body.toFOLString() + ": " + 
				   _body._hsFreeVarsOut);
		System.exit(1);
	    }
	}
	public int hashCode() {
	    return _head.hashCode() - (_body.hashCode() << 1);
	}
	public boolean equals(Object o) {
	    Rule r = (Rule)o;
	    return _head.equals(r._head) && _body.equals(r._body);
	}
	public String toString() {
	    return _head.toFOLString() + " <= " + _body.toFOLString();
	}
    }

    /** Internal class for storing canonical ground PNode and bindings
     **/
    public static class GroundBindings {
	public FOPC.PNode _prototype; // Prototype corresponding to bindings
	public Bindings   _bindings;  // Actual ground bindings
	public GroundBindings(FOPC.PNode prototype, Bindings bindings) {
	    _prototype = prototype;
	    _bindings  = bindings;
	}
	public String toString() {
	    return "Prototype: " + 
		_prototype.toFOLString() + "\n-------------------\n" + _bindings;
	}
    }

    /** Internal representation of bindings
     **/
    public static class Bindings {
	public ArrayList _vars;     // List of TVars (same width as _bindings sublists)
	public HashSet   _bindings; // A list of lists (where sublists corresponds to vars)
	                            // and contains instances of TFunction

	public Bindings(ArrayList vars) {
	    _vars = vars;
	    _bindings = new HashSet();
	}

	public Object clone() {
	    Bindings b = new Bindings((ArrayList)_vars.clone());
	    b._bindings.addAll(_bindings);
	    return b;
	}
		
	public ArrayList getVars() {
	    return _vars;
	}

	public int getNumEntries() {
	    return _bindings.size();
	}

	// HashSet automatically checks redundancy
	public void addEntry(ArrayList bindings) {
	    _bindings.add(bindings);
	}

	public boolean containsEntry(ArrayList bindings) {
	    return _bindings.contains(bindings);
	}

	public Iterator getIterator() {
	    return _bindings.iterator();
	}

	public String toString() {
	    StringBuffer sb = new StringBuffer("Var order: [ ");
	    Iterator i = _vars.iterator();
	    while (i.hasNext()) {
		FOPC.TVar v = (FOPC.TVar)i.next();
		sb.append(v.toFOLString() + " ");
	    }
	    sb.append("]\n");

	    i = _bindings.iterator();
	    int index = 0;
	    while (i.hasNext()) {
		sb.append(index + ": [ ");
		Iterator j = ((ArrayList)i.next()).iterator();
		while (j.hasNext()) {
		    FOPC.Term t = (FOPC.Term)j.next();
		    if (t == null) {
			sb.append("*null* ");
		    } else {
			sb.append(t.toFOLString() + " ");
		    }
		}
		sb.append("]\n");
		index++;
	    }
	    return sb.toString();
	}
	
	public BindingSet convert2BindingSet() {

	    BindingSet bs = new BindingSet();
	    Iterator i = _vars.iterator();
	    while (i.hasNext()) {
		bs.addVar(((FOPC.TVar)i.next()).toFOLString());
	    }

	    Iterator j = _bindings.iterator();
	    while (j.hasNext()) {
		ArrayList binding = (ArrayList)j.next();
		i = _vars.iterator();
		Iterator k = binding.iterator();
		int entry_id = bs.makeNewBindingEntry();
		while (i.hasNext()) {
		    bs.addBinding(entry_id, ((FOPC.TVar)i.next()).toFOLString(), 
				  ((FOPC.Term)k.next()).toFOLString());
		}
	    }

	    return bs.seal();
	}
    }

    // Build a simple test kb
    public static void main(String[] args) {

	Test1();
	Test2();

    }

    public static void Test1() {

	PrologKb kb = new PrologKb(null);

	kb.addFOPCFormula("(!E ?y Conn(?x,?y) ^ Conn(?y,?z)) => BConn(?x,?z)"); // Project out ?y
	kb.addFOPCFormula("Conn(1,2)");
	kb.addFOPCFormula("Conn(2,3)");
	kb.addFOPCFormula("Conn(3,4)");
	kb.addFOPCFormula("Conn(3,5)");
	kb.addFOPCFormula("Conn(3,5)"); // Duplicates removed!
	kb.addFOPCFormula("Univ(5)");
	
	System.out.println(kb);
    }

    public static void Test2() {

	HashSet domain = new HashSet();
	domain.add(new FOPC.TInteger(1));
	domain.add(new FOPC.TInteger(2));
	domain.add(new FOPC.TInteger(3));
	domain.add(new FOPC.TInteger(4));
	domain.add(new FOPC.TInteger(5));
	domain.add(new FOPC.TInteger(6));
	PrologKb kb = new PrologKb(domain);

	kb.addFOPCFormula("(!E ?y Conn(?x,?y) ^ Conn(?y,?z)) => DConn(?x,?z)"); // Project out ?y
	kb.addFOPCFormula("(Conn(?x,?y) ^ Conn(?y,?x)) => BConn(?x,?y)"); // Test join
	kb.addFOPCFormula("(TOP_DOMAIN(?y) ^ Univ(?x)) => TConn(?x,?y)"); // Let ?y match all
	kb.addFOPCFormula("BConn(?x,?y) => FConn(?x,g(?y))");
	kb.addFOPCFormula("(Conn(?x,1) | Conn(?x,2)) => GConn(?x)"); // Test join
	//kb.addFOPCFormula("(TOP_DOMAIN(?x) ^ Univ(?x)) => T2Conn(?x,?x)"); // No repeated vars in head
	//kb.addFOPCFormula("Conn(?x,f(?x)) => Conn(?x,g(?x))"); // Cannot have recursive rule
	kb.addFOPCFormula("Conn(1,2)");
	kb.addFOPCFormula("Conn(2,1)");
	kb.addFOPCFormula("Conn(2,2)");
	kb.addFOPCFormula("Conn(2,3)");
	kb.addFOPCFormula("Conn(3,2)");
	kb.addFOPCFormula("Conn(3,4)");
	kb.addFOPCFormula("Conn(3,5)");
	kb.addFOPCFormula("Conn(3,5)"); // Duplicates removed!
	kb.addFOPCFormula("Conn(f(1),f(1))");
	kb.addFOPCFormula("Conn(1,f(1))");
	kb.addFOPCFormula("Conn(1,f(2))");
	kb.addFOPCFormula("Conn(2,f(1))");
	kb.addFOPCFormula("Conn(2,f(2))");
	kb.addFOPCFormula("Conn(3,f(3))");
	kb.addFOPCFormula("Conn(4,f(5))");
	kb.addFOPCFormula("Univ(5)");
	kb.addFOPCFormula("up");
	
	System.out.println(kb);
	QueryBindings(kb, "Conn(?x,?y)");
	QueryBindings(kb, "~Conn(?x,?y)");
	QueryBindings(kb, "BConn(?x,?y)");
	QueryBindings(kb, "~BConn(?x,?y)");
	QueryBindings(kb, "Conn(?x,?x)");
	QueryBindings(kb, "TConn(?x,?x)");
	QueryBindings(kb, "TConn(?x,?y)");
	QueryBindings(kb, "FConn(?x,?y)");	
	QueryBindings(kb, "FConn(?x,g(?x))");
	QueryBindings(kb, "FConn(?x,g(?y))");
	QueryBindings(kb, "Conn(?x,f(?x))");
	QueryBindings(kb, "Conn(?x,f(?y))");
	QueryBindings(kb, "Conn(f(?x),f(?x))");
	QueryBindings(kb, "(!E ?y Conn(?x,?y) ^ Conn(?y,?z))");
	QueryBindings(kb, "(!E ?y !E ?z Conn(?x,?y) ^ Conn(?y,?z))");
	QueryBindings(kb, "DConn(?a,?b)");
	QueryBindings(kb, "GConn(?a)");
	QueryBindings(kb, "!A ?a TConn(?a,?b)");	
	QueryBindings(kb, "!A ?b TConn(?a,?b)");	
	QueryBindings(kb, "!A ?a !A ?b TConn(?a,?b)");	
	QueryTF(kb, "BConn(2,3)");
	QueryTF(kb, "BConn(2,4)");
	QueryTF(kb, "BConn(2,?x)");
	QueryBindings(kb, "BConn(2,?x)");
	QueryTF(kb, "BConn(?y,?x)");
	QueryBindings(kb, "Conn(?y,?x)");
	QueryBindings(kb, "Conn(?y,?x) ^ ?x=?y");
	QueryBindings(kb, "Conn(?y,?x) ^ ?x~=?y");
	QueryBindings(kb, "Conn(?y,?x) ^ ?x~=2");
	QueryBindings(kb, "BConn(?y,?x)");
	QueryBindings(kb, "BConn(?y,?x) ^ ?x~=2");
	QueryTF(kb, "up");
	QueryTF(kb, "down");
	QueryBindings(kb, "up ^ BConn(?y,?x) ^ ?x~=2");
	QueryBindings(kb, "down ^ BConn(?y,?x) ^ ?x~=2");
    }

    public static void QueryBindings(PrologKb kb, String query) {
	System.out.println("Query: " + query);
	System.out.println(kb.queryFOPCBindings(query));
    }

    public static void QueryTF(PrologKb kb, String query) {
	System.out.println("Query: " + query);
	System.out.println(kb.queryFOPC(query));
    }

}
